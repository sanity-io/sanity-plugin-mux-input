import {DocumentVideoIcon, ErrorOutlineIcon, UploadIcon} from '@sanity/icons'
import {Box, Button, Card, Checkbox, Dialog, Flex, Label, Radio, Stack, Text} from '@sanity/ui'
import {uuid} from '@sanity/uuid'
import LanguagesList from 'iso-639-1'
import {useEffect, useId, useMemo, useReducer, useRef, useState} from 'react'
import {FormField} from 'sanity'

import formatBytes from '../util/formatBytes'
import {formatSeconds} from '../util/formatSeconds'
import {
  type AutogeneratedTextTrack,
  type CustomTextTrack,
  isAutogeneratedTrack,
  isCustomTextTrack,
  type MuxNewAssetSettings,
  type PluginConfig,
  type Secrets,
  type StaticRenditionResolution,
  type SupportedMuxLanguage,
  type UploadConfig,
  type UploadTextTrack,
} from '../util/types'
import TextTracksEditor, {type TrackAction} from './TextTracksEditor'
import PlaybackPolicy from './uploadConfiguration/PlaybackPolicy'
import type {StagedUpload} from './Uploader'

export type UploadConfigurationStateAction =
  | {action: 'video_quality'; value: UploadConfig['video_quality']}
  | {action: 'max_resolution_tier'; value: UploadConfig['max_resolution_tier']}
  | {action: 'static_renditions'; value: UploadConfig['static_renditions']}
  | {action: 'normalize_audio'; value: UploadConfig['normalize_audio']}
  | {action: 'signed_policy'; value: UploadConfig['signed_policy']}
  | {action: 'public_policy'; value: UploadConfig['public_policy']}
  | TrackAction

const VIDEO_QUALITY_LEVELS = [
  {value: 'basic', label: 'Basic'},
  {value: 'plus', label: 'Plus'},
  {value: 'premium', label: 'Premium'},
] as const satisfies {value: UploadConfig['video_quality']; label: string}[]

const RESOLUTION_TIERS = [
  {value: '1080p', label: '1080p'},
  {value: '1440p', label: '1440p (2k)'},
  {value: '2160p', label: '2160p (4k)'},
] as const satisfies {value: UploadConfig['max_resolution_tier']; label: string}[]

const ADVANCED_RESOLUTIONS: {value: StaticRenditionResolution; label: string}[] = [
  {value: '270p', label: '270p'},
  {value: '360p', label: '360p'},
  {value: '480p', label: '480p'},
  {value: '540p', label: '540p'},
  {value: '720p', label: '720p'},
  {value: '1080p', label: '1080p'},
  {value: '1440p', label: '1440p'},
  {value: '2160p', label: '2160p'},
]

/**
 * Sanitizes static renditions configuration to ensure 'highest' is not mixed with specific resolutions.
 * If both are present, only 'highest' (and 'audio-only' if present) will be kept.
 */
function sanitizeStaticRenditions(
  renditions: StaticRenditionResolution[]
): StaticRenditionResolution[] {
  const hasHighest = renditions.includes('highest')
  const hasSpecificResolutions = renditions.some((r) => r !== 'highest' && r !== 'audio-only')

  if (hasHighest && hasSpecificResolutions) {
    return renditions.filter((r) => r === 'highest' || r === 'audio-only')
  }

  return renditions
}

/**
 * The modal for configuring a staged upload. Handles triggering of the asset
 * upload, even if no modal needs to be shown.
 *
 * @returns
 */
export default function UploadConfiguration({
  stagedUpload,
  secrets,
  pluginConfig,
  startUpload,
  onClose,
}: {
  stagedUpload: StagedUpload
  secrets: Secrets
  pluginConfig: PluginConfig
  startUpload: (settings: MuxNewAssetSettings) => void
  onClose: () => void
}) {
  const id = useId()
  const autoTextTracks = useRef<NonNullable<UploadConfig['text_tracks']>>(
    pluginConfig.video_quality === 'plus' && pluginConfig.defaultAutogeneratedSubtitleLang
      ? [
          {
            _id: uuid(),
            type: 'autogenerated',
            language_code: pluginConfig.defaultAutogeneratedSubtitleLang,
            name: LanguagesList.getNativeName(pluginConfig.defaultAutogeneratedSubtitleLang),
          } satisfies AutogeneratedTextTrack,
        ]
      : []
  ).current

  const [config, dispatch] = useReducer(
    (prev: UploadConfig, action: UploadConfigurationStateAction) => {
      switch (action.action) {
        case 'video_quality':
          // If video quality level switches to basic, remove plus-only features
          if (action.value === 'basic') {
            return Object.assign({}, prev, {
              video_quality: action.value,
              static_renditions: [],
              max_resolution_tier: '1080p',
              text_tracks: prev.text_tracks?.filter(({type}) => type !== 'autogenerated'),
              public_policy: true,
              signed_policy: false,
            })
            // If video quality level switches to plus, add back in default plus features
          }
          return Object.assign({}, prev, {
            video_quality: action.value,
            static_renditions: sanitizeStaticRenditions(pluginConfig.static_renditions || []),
            max_resolution_tier: pluginConfig.max_resolution_tier,
            text_tracks: [...autoTextTracks, ...(prev.text_tracks || [])],
          })

        case 'static_renditions':
        case 'max_resolution_tier':
        case 'normalize_audio':
        case 'signed_policy':
          return Object.assign({}, prev, {[action.action]: action.value})
        case 'public_policy':
          return Object.assign({}, prev, {[action.action]: action.value})
        // Updating individual tracks
        case 'track': {
          const text_tracks = [...prev.text_tracks]
          const target_track_i = text_tracks.findIndex(({_id}) => _id === action.id)
          // eslint-disable-next-line default-case
          switch (action.subAction) {
            case 'add':
              // Exit early if track already exists
              if (target_track_i !== -1) break
              text_tracks.push({
                _id: action.id,
                ...action.value,
              } as AutogeneratedTextTrack)
              break
            case 'update':
              if (target_track_i === -1) break
              text_tracks[target_track_i] = {
                ...text_tracks[target_track_i],
                ...action.value,
              } as UploadTextTrack
              break
            case 'delete':
              if (target_track_i === -1) break
              text_tracks.splice(target_track_i, 1)
              break
          }
          return Object.assign({}, prev, {text_tracks})
        }
        default:
          return prev
      }
    },
    {
      video_quality: pluginConfig.video_quality,
      max_resolution_tier: pluginConfig.max_resolution_tier,
      static_renditions: sanitizeStaticRenditions(pluginConfig.static_renditions || []),
      signed_policy: secrets.enableSignedUrls && pluginConfig.defaultSigned,
      public_policy: pluginConfig.defaultPublic,
      normalize_audio: pluginConfig.normalize_audio,
      text_tracks: autoTextTracks,
    } as UploadConfig
  )

  // Determine if user is in advanced mode based on selected renditions
  const isAdvancedMode = useMemo(() => {
    const specificResolutions = config.static_renditions.filter(
      (r) => r !== 'highest' && r !== 'audio-only'
    )
    return specificResolutions.length > 0
  }, [config.static_renditions])

  const [renditionMode, setRenditionMode] = useState<'standard' | 'advanced'>(
    isAdvancedMode ? 'advanced' : 'standard'
  )

  // Video validations
  const [videoDuration, setVideoDuration] = useState<number | null>(null)
  const [urlFileSize, setUrlFileSize] = useState<number | null>(null)
  const [isLoadingDuration, setIsLoadingDuration] = useState(false)
  const [isLoadingFileSize, setIsLoadingFileSize] = useState(false)
  const [validationError, setValidationError] = useState<string | null>(null)

  const MAX_FILE_SIZE = pluginConfig.maxAssetFileSize
  const MAX_DURATION_SECONDS = pluginConfig.maxAssetDuration

  useEffect(() => {
    setVideoDuration(null)
    setUrlFileSize(null)
    setIsLoadingDuration(false)
    setIsLoadingFileSize(false)
    setValidationError(null)

    const validateDuration = (videoSrc: string, shouldRevokeUrl = false) => {
      if (!MAX_DURATION_SECONDS || MAX_DURATION_SECONDS <= 0) return

      setIsLoadingDuration(true)
      const video = document.createElement('video')
      video.preload = 'metadata'

      video.onloadedmetadata = () => {
        if (shouldRevokeUrl) URL.revokeObjectURL(video.src)
        const duration = video.duration
        setVideoDuration(duration)
        setIsLoadingDuration(false)

        if (duration > MAX_DURATION_SECONDS) {
          setValidationError(
            `Video duration (${formatSeconds(duration)}) exceeds maximum allowed duration of ${formatSeconds(MAX_DURATION_SECONDS)}`
          )
        }
      }

      video.onerror = () => {
        if (shouldRevokeUrl) URL.revokeObjectURL(video.src)
        setIsLoadingDuration(false)
        console.warn('Could not read video metadata for validation')
      }

      video.src = videoSrc
    }

    const validateFileSize = (size: number): boolean => {
      if (MAX_FILE_SIZE === undefined || size <= MAX_FILE_SIZE) {
        return true
      }

      setValidationError(
        `File size (${formatBytes(size)}) exceeds maximum allowed size of ${formatBytes(MAX_FILE_SIZE)}`
      )
      return false
    }

    // Validate file uploads
    if (stagedUpload.type === 'file') {
      const file = stagedUpload.files[0]
      if (validateFileSize(file.size)) {
        validateDuration(URL.createObjectURL(file), true)
      }
      return
    }

    // Validate URL uploads
    if (stagedUpload.type === 'url') {
      const url = stagedUpload.url

      // Get file size from URL
      setIsLoadingFileSize(true)
      fetch(url, {method: 'HEAD'})
        .then((response) => {
          const contentLength = response.headers.get('content-length')
          const fileSize = contentLength ? parseInt(contentLength, 10) : null

          setIsLoadingFileSize(false)
          if (fileSize) {
            setUrlFileSize(fileSize)
          }

          // Validate file size if limit is configured
          if (MAX_FILE_SIZE !== undefined && fileSize) {
            if (validateFileSize(fileSize)) {
              validateDuration(url)
            }
          } else {
            validateDuration(url)
          }
        })
        .catch(() => {
          setIsLoadingFileSize(false)
          console.warn('Could not validate file size from URL')
          validateDuration(url)
        })
    }
  }, [stagedUpload, MAX_FILE_SIZE, MAX_DURATION_SECONDS])

  // Helper to toggle a rendition
  const toggleRendition = (rendition: StaticRenditionResolution) => {
    const current = config.static_renditions
    const hasRendition = current.includes(rendition)

    if (hasRendition) {
      dispatch({
        action: 'static_renditions',
        value: current.filter((r) => r !== rendition),
      })
    } else {
      dispatch({
        action: 'static_renditions',
        value: [...current, rendition],
      })
    }
  }

  // When switching modes, clear renditions that don't apply
  const handleModeChange = (mode: 'standard' | 'advanced') => {
    setRenditionMode(mode)
    if (mode === 'standard') {
      // Remove specific resolutions, keep only highest and audio-only
      dispatch({
        action: 'static_renditions',
        value: config.static_renditions.filter((r) => r === 'highest' || r === 'audio-only'),
      })
    } else {
      // Remove highest, keep specific resolutions and audio-only
      dispatch({
        action: 'static_renditions',
        value: config.static_renditions.filter((r) => r !== 'highest'),
      })
    }
  }

  // If user-provided config is disabled, begin the upload immediately with
  // the developer-specified values from the schema or config or defaults.
  // This can include auto-generated subtitles!
  const {disableTextTrackConfig, disableUploadConfig} = pluginConfig
  const skipConfig = disableTextTrackConfig && disableUploadConfig
  useEffect(() => {
    if (skipConfig) startUpload(formatUploadConfig(config))
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])
  if (skipConfig) return null

  const basicConfig = config.video_quality !== 'plus' && config.video_quality !== 'premium'
  const maxSupportedResolution = RESOLUTION_TIERS.findIndex(
    (rt) => rt.value === pluginConfig.max_resolution_tier
  )
  return (
    <Dialog
      animate
      open
      id="upload-configuration"
      zOffset={1000}
      width={1}
      header="Configure Mux Upload"
      onClose={onClose}
    >
      <Stack padding={4} space={2}>
        {validationError && (
          <Card padding={3} tone="critical" radius={2} marginBottom={2}>
            <Flex gap={2} align="flex-start">
              <ErrorOutlineIcon width={20} height={20} />
              <Stack space={2}>
                <Text size={1} weight="semibold">
                  Validation Error
                </Text>
                <Text size={1}>{validationError}</Text>
              </Stack>
            </Flex>
          </Card>
        )}
        <Label size={3}>FILE TO UPLOAD</Label>
        <Card
          tone="transparent"
          border
          padding={3}
          paddingY={4}
          style={{borderRadius: '0.1865rem'}}
        >
          <Flex gap={2}>
            <DocumentVideoIcon fontSize="2em" />
            <Stack space={2}>
              <Text textOverflow="ellipsis" as="h2" size={3}>
                {stagedUpload.type === 'file' ? stagedUpload.files[0].name : stagedUpload.url}
              </Text>
              <Text as="p" size={1} muted>
                {stagedUpload.type === 'file'
                  ? `Direct File Upload (${formatBytes(stagedUpload.files[0].size)})`
                  : (() => {
                      if (urlFileSize) {
                        return `File From URL (${formatBytes(urlFileSize)})`
                      }
                      if (isLoadingFileSize) {
                        return 'File From URL (Loading size...)'
                      }
                      return 'File From URL (Unknown size)'
                    })()}
              </Text>
              {stagedUpload.type === 'file' && (
                <Stack space={1}>
                  {isLoadingDuration && (
                    <Text as="p" size={1} muted>
                      Reading video metadata...
                    </Text>
                  )}
                  {videoDuration !== null && !validationError && (
                    <Text as="p" size={1} muted>
                      Duration: {formatSeconds(videoDuration)}
                    </Text>
                  )}
                </Stack>
              )}
            </Stack>
          </Flex>
        </Card>
        {!disableUploadConfig && (
          <Stack space={3} paddingBottom={2}>
            <FormField
              title="Video Quality Level"
              description={
                <>
                  The video quality level informs the cost, quality, and available platform features
                  for the asset.{' '}
                  <a
                    href="https://docs.mux.com/guides/use-encoding-tiers"
                    target="_blank"
                    rel="noopener noreferrer"
                  >
                    See the Mux guide for more details.
                  </a>
                </>
              }
            >
              <Flex gap={3}>
                {VIDEO_QUALITY_LEVELS.map(({value, label}) => {
                  const inputId = `${id}--encodingtier-${value}`
                  return (
                    <Flex key={value} align="center" gap={2}>
                      <Radio
                        checked={config.video_quality === value}
                        name="asset-encodingtier"
                        onChange={(e) =>
                          dispatch({
                            action: 'video_quality' as const,
                            value: e.currentTarget.value as UploadConfig['video_quality'],
                          })
                        }
                        value={value}
                        id={inputId}
                      />
                      <Text as="label" htmlFor={inputId}>
                        {label}
                      </Text>
                    </Flex>
                  )
                })}
              </Flex>
            </FormField>

            {!basicConfig && maxSupportedResolution > 0 && (
              <FormField
                title="Resolution Tier"
                description={
                  <>
                    The maximum{' '}
                    <a
                      href="https://docs.mux.com/api-reference#video/operation/create-direct-upload"
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      resolution_tier
                    </a>{' '}
                    your asset is encoded, stored, and streamed at.
                  </>
                }
              >
                <Flex gap={3} wrap={'wrap'}>
                  {RESOLUTION_TIERS.map(({value, label}, index) => {
                    const inputId = `${id}--type-${value}`

                    if (index > maxSupportedResolution) return null

                    return (
                      <Flex key={value} align="center" gap={2}>
                        <Radio
                          checked={config.max_resolution_tier === value}
                          name="asset-resolutiontier"
                          onChange={(e) =>
                            dispatch({
                              action: 'max_resolution_tier',
                              value: e.currentTarget.value as UploadConfig['max_resolution_tier'],
                            })
                          }
                          value={value}
                          id={inputId}
                        />
                        <Text as="label" htmlFor={inputId}>
                          {label}
                        </Text>
                      </Flex>
                    )
                  })}
                </Flex>
              </FormField>
            )}

            {!basicConfig && (
              <FormField title="Additional Configuration">
                <Stack space={3}>
                  <PlaybackPolicy id={id} config={config} secrets={secrets} dispatch={dispatch} />

                  <Stack space={3}>
                    <FormField
                      title="Static Renditions"
                      description="Generate downloadable MP4 or M4A files. Note: Mux will not upscale to produce MP4 renditions - renditions that would cause upscaling are skipped."
                    >
                      <Stack space={3}>
                        {/* Mode Selector */}
                        <Flex gap={3}>
                          <Flex align="center" gap={2}>
                            <Radio
                              checked={renditionMode === 'standard'}
                              name="rendition-mode"
                              onChange={() => handleModeChange('standard')}
                              value="standard"
                              id={`${id}--mode-standard`}
                            />
                            <Text as="label" htmlFor={`${id}--mode-standard`}>
                              Standard
                            </Text>
                          </Flex>
                          <Flex align="center" gap={2}>
                            <Radio
                              checked={renditionMode === 'advanced'}
                              name="rendition-mode"
                              onChange={() => handleModeChange('advanced')}
                              value="advanced"
                              id={`${id}--mode-advanced`}
                            />
                            <Text as="label" htmlFor={`${id}--mode-advanced`}>
                              Advanced
                            </Text>
                          </Flex>
                        </Flex>

                        {/* Standard Mode Options */}
                        {renditionMode === 'standard' && (
                          <Stack space={2}>
                            <Flex align="center" gap={2} padding={[0, 2]}>
                              <Checkbox
                                id={`${id}--highest`}
                                style={{display: 'block'}}
                                checked={config.static_renditions.includes('highest')}
                                onChange={() => toggleRendition('highest')}
                              />
                              <Text as="label" htmlFor={`${id}--highest`}>
                                Highest Resolution (up to 4K)
                              </Text>
                            </Flex>
                            <Flex align="center" gap={2} padding={[0, 2]}>
                              <Checkbox
                                id={`${id}--audio-only-standard`}
                                style={{display: 'block'}}
                                checked={config.static_renditions.includes('audio-only')}
                                onChange={() => toggleRendition('audio-only')}
                              />
                              <Text as="label" htmlFor={`${id}--audio-only-standard`}>
                                Audio Only (M4A)
                              </Text>
                            </Flex>
                          </Stack>
                        )}

                        {/* Advanced Mode Options */}
                        {renditionMode === 'advanced' && (
                          <Stack space={2}>
                            <Label size={1} muted>
                              Select specific resolutions:
                            </Label>
                            <Flex gap={2} wrap="wrap">
                              {ADVANCED_RESOLUTIONS.map(({value, label}) => {
                                const inputId = `${id}--resolution-${value}`
                                return (
                                  <Flex key={value} align="center" gap={2}>
                                    <Checkbox
                                      id={inputId}
                                      style={{display: 'block'}}
                                      checked={config.static_renditions.includes(value)}
                                      onChange={() => toggleRendition(value)}
                                    />
                                    <Text as="label" htmlFor={inputId} size={1}>
                                      {label}
                                    </Text>
                                  </Flex>
                                )
                              })}
                            </Flex>
                            <Flex align="center" gap={2} padding={[2, 2, 0, 2]}>
                              <Checkbox
                                id={`${id}--audio-only-advanced`}
                                style={{display: 'block'}}
                                checked={config.static_renditions.includes('audio-only')}
                                onChange={() => toggleRendition('audio-only')}
                              />
                              <Text as="label" htmlFor={`${id}--audio-only-advanced`}>
                                Audio Only (M4A)
                              </Text>
                            </Flex>
                          </Stack>
                        )}
                      </Stack>
                    </FormField>
                  </Stack>
                </Stack>
              </FormField>
            )}
          </Stack>
        )}

        {!disableTextTrackConfig && !basicConfig && (
          <TextTracksEditor
            tracks={config.text_tracks}
            dispatch={dispatch}
            defaultLang={pluginConfig.defaultAutogeneratedSubtitleLang}
          />
        )}

        <Box marginTop={4}>
          <Button
            disabled={
              (!basicConfig && !config.public_policy && !config.signed_policy) ||
              validationError !== null ||
              isLoadingDuration ||
              isLoadingFileSize
            }
            icon={UploadIcon}
            text="Upload"
            tone="positive"
            onClick={() => {
              if (!validationError) {
                startUpload(formatUploadConfig(config))
              }
            }}
          />
        </Box>
      </Stack>
    </Dialog>
  )
}

function setPlaybackPolicy(config: UploadConfig): MuxNewAssetSettings['playback_policy'] {
  const playback_policy: MuxNewAssetSettings['playback_policy'] = []
  if (config.public_policy) {
    playback_policy.push('public')
  }
  if (config.signed_policy) {
    playback_policy.push('signed')
  }
  return playback_policy
}

function formatUploadConfig(config: UploadConfig): MuxNewAssetSettings {
  const generated_subtitles = config.text_tracks
    .filter<AutogeneratedTextTrack>(isAutogeneratedTrack)
    .map<{name: string; language_code: SupportedMuxLanguage}>((track) => ({
      name: track.name,
      language_code: track.language_code,
    }))

  return {
    input: [
      {
        type: 'video',
        generated_subtitles: generated_subtitles.length > 0 ? generated_subtitles : undefined,
      },
      ...config.text_tracks.filter<CustomTextTrack>(isCustomTextTrack).reduce(
        (acc, track) => {
          if (track.language_code && track.file && track.name) {
            acc.push({
              url: track.file.contents,
              type: 'text',
              text_type: track.type === 'subtitles' ? 'subtitles' : undefined,
              language_code: track.language_code,
              name: track.name,
              closed_captions: track.type === 'captions',
            })
          }
          return acc
        },
        [] as NonNullable<MuxNewAssetSettings['input']>
      ),
    ],
    static_renditions:
      config.static_renditions.length > 0
        ? config.static_renditions.map((resolution) => ({resolution}))
        : undefined,
    playback_policy: setPlaybackPolicy(config),
    max_resolution_tier: config.max_resolution_tier,
    video_quality: config.video_quality,
    normalize_audio: config.normalize_audio,
  }
}

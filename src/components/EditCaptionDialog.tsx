import {DownloadIcon, TranslateIcon, UploadIcon} from '@sanity/icons'
import {
  Autocomplete,
  Button,
  Card,
  Dialog,
  Flex,
  Label,
  Spinner,
  Stack,
  Text,
  TextInput,
  useToast,
} from '@sanity/ui'
import LanguagesList from 'iso-639-1'
import {useEffect, useId, useState} from 'react'

import {addTextTrackFromUrl, deleteTextTrack, getAsset} from '../actions/assets'
import {useClient} from '../hooks/useClient'
import {generateJwt} from '../util/generateJwt'
import {getPlaybackId} from '../util/getPlaybackId'
import {getPlaybackPolicy} from '../util/getPlaybackPolicy'
import {pollTrackStatus} from '../util/pollTrackStatus'
import type {MuxTextTrack, VideoAssetDocument} from '../util/types'

const LANGUAGE_OPTIONS = LanguagesList.getAllCodes().map((code) => ({
  value: code,
  label: LanguagesList.getNativeName(code),
}))

export interface Props {
  asset: VideoAssetDocument
  track: MuxTextTrack
  onUpdate: (track: MuxTextTrack, oldTrackId?: string) => void
  onClose: () => void
}

export default function EditCaptionDialog({asset, track, onUpdate, onClose}: Props) {
  const client = useClient()
  const toast = useToast()
  const dialogId = `EditCaptionDialog${useId()}`

  const isAutogenerated =
    track.text_source === 'generated_live' ||
    track.text_source === 'generated_live_final' ||
    track.text_source === 'generated_vod'

  const [vttUrl, setVttUrl] = useState(() => {
    if (isAutogenerated || !track.id) return ''
    const playbackId = getPlaybackId(asset)
    if (!playbackId) return ''
    let url = `https://stream.mux.com/${playbackId}/text/${track.id}.vtt`
    if (getPlaybackPolicy(asset) === 'signed') {
      const token = generateJwt(client, playbackId, 'v')
      url += `?token=${token}`
    }
    return url
  })
  const [languageCode, setLanguageCode] = useState(track.language_code || '')
  const [selectedLanguage, setSelectedLanguage] = useState<{value: string; label: string} | null>(
    () => {
      const baseCode = track.language_code?.split('-')[0]
      const found = LANGUAGE_OPTIONS.find(
        (opt) => opt.value === track.language_code || opt.value === baseCode
      )
      if (found) return found
      if (track.name) {
        const foundByName = LANGUAGE_OPTIONS.find((opt) => opt.label === track.name)
        if (foundByName) return foundByName
      }
      return null
    }
  )
  const [name, setName] = useState(track.name || '')
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [downloading, setDownloading] = useState(false)

  useEffect(() => {
    setLanguageCode(track.language_code || '')
    setName(track.name || '')
    const isAutogeneratedTrack =
      track.text_source === 'generated_live' ||
      track.text_source === 'generated_live_final' ||
      track.text_source === 'generated_vod'
    if (!isAutogeneratedTrack && track.id) {
      const playbackId = getPlaybackId(asset)
      if (playbackId) {
        let url = `https://stream.mux.com/${playbackId}/text/${track.id}.vtt`
        if (getPlaybackPolicy(asset) === 'signed') {
          const token = generateJwt(client, playbackId, 'v')
          url += `?token=${token}`
        }
        setVttUrl(url)
      } else {
        setVttUrl('')
      }
    } else {
      setVttUrl('')
    }
    const baseCode = track.language_code?.split('-')[0]
    const foundByCode = LANGUAGE_OPTIONS.find(
      (opt) => opt.value === track.language_code || opt.value === baseCode
    )
    const foundByName = track.name ? LANGUAGE_OPTIONS.find((opt) => opt.label === track.name) : null
    setSelectedLanguage(foundByCode || foundByName || null)
  }, [track, asset, client])

  const handleDownloadCurrentFile = async () => {
    if (!track.id) {
      toast.push({
        title: 'Cannot download',
        status: 'error',
        description: 'Track ID is missing',
      })
      return
    }

    if (track.status !== 'ready') {
      toast.push({
        title: 'Cannot download',
        status: 'error',
        description: `Track is not ready yet. Status: ${track.status}`,
      })
      return
    }

    setDownloading(true)
    try {
      if (!asset.assetId) {
        throw new Error('Asset ID is required')
      }

      const playbackId = getPlaybackId(asset)
      if (!playbackId) {
        throw new Error('Playback ID is required')
      }

      const playbackPolicy = getPlaybackPolicy(asset)

      let downloadUrl = `https://stream.mux.com/${playbackId}/text/${track.id}.vtt`

      if (playbackPolicy === 'signed') {
        const token = generateJwt(client, playbackId, 'v')
        downloadUrl += `?token=${token}`
      }

      const response = await fetch(downloadUrl)
      if (!response.ok) {
        throw new Error(`Failed to download file: ${response.statusText}`)
      }

      const blob = await response.blob()
      const blobUrl = URL.createObjectURL(blob)

      const link = document.createElement('a')
      link.href = blobUrl
      link.download = `${asset.filename || 'captions'}-${track.language_code || 'en'}.vtt`
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)

      URL.revokeObjectURL(blobUrl)
    } catch (error) {
      toast.push({
        title: 'Failed to download VTT file',
        status: 'error',
        description: error instanceof Error ? error.message : 'Please try again',
      })
    } finally {
      setDownloading(false)
    }
  }

  const getCurrentFileName = () => {
    if (track.id && asset.filename) {
      return `${asset.filename}-${track.language_code || 'en'}.vtt`
    }
    return `captions-${track.language_code || 'en'}.vtt`
  }

  const handleUpdateTrackWithNewUrl = async () => {
    if (!asset.assetId) {
      throw new Error('Asset ID is required')
    }

    const trimmedName = name.trim()
    const trimmedLanguageCode = languageCode.trim()

    const oldTrackId = track.id

    try {
      await deleteTextTrack(client, asset.assetId, oldTrackId)
    } catch (deleteError) {
      toast.push({
        title: 'Failed to delete old track',
        status: 'error',
        description: 'Could not delete the old track. Please try again or delete it manually.',
      })
      setIsSubmitting(false)
      throw deleteError
    }

    try {
      await addTextTrackFromUrl(client, asset.assetId, vttUrl.trim(), {
        language_code: trimmedLanguageCode,
        name: trimmedName,
        text_type: 'subtitles',
      })
    } catch (error: unknown) {
      let errorMessage = 'Failed to add caption track'

      if (error && typeof error === 'object') {
        const err = error as {response?: {body?: {message?: string}}; message?: string}
        if (err.response?.body?.message) {
          errorMessage = err.response.body.message
        } else if (err.message) {
          errorMessage = err.message
        }
      } else if (typeof error === 'string') {
        errorMessage = error
      }

      toast.push({
        title: 'Failed to update caption track',
        status: 'error',
        description: errorMessage,
      })
      setIsSubmitting(false)
      throw error
    }

    const result = await pollTrackStatus({
      client,
      assetId: asset.assetId,
      trackName: trimmedName,
      trackLanguageCode: trimmedLanguageCode,
      onTrackErrored: async (erroredTrack) => {
        const errorMessage =
          erroredTrack.error?.messages?.[0] ||
          erroredTrack.error?.type ||
          'The track failed to download from the provided URL'
        toast.push({
          title: 'Caption track failed',
          status: 'error',
          description: errorMessage,
        })
        if (asset._id && asset.assetId) {
          try {
            const latestAssetData = await getAsset(client, asset.assetId)
            await client
              .patch(asset._id)
              .set({data: latestAssetData.data, status: latestAssetData.data.status})
              .commit()
          } catch (refreshError) {
            console.error('Failed to refresh asset data:', refreshError)
          }
        }
        onUpdate(erroredTrack, oldTrackId)
        setIsSubmitting(false)
      },
    })

    if (!result.found || !result.track) {
      toast.push({
        title: 'Caption track may have been updated',
        status: 'warning',
        description:
          'The track was updated but its status could not be determined. It may still be processing. Please refresh the page to see if it appears.',
      })
      setIsSubmitting(false)
      return
    }

    if (result.status === 'errored') {
      return
    }

    if (asset._id) {
      try {
        const latestAssetData = await getAsset(client, asset.assetId)
        await client
          .patch(asset._id)
          .set({data: latestAssetData.data, status: latestAssetData.data.status})
          .commit()
      } catch (refreshError) {
        console.error('Failed to refresh asset data:', refreshError)
      }
    }

    if (result.status === 'preparing') {
      toast.push({
        title: 'Caption track is processing',
        status: 'info',
        description:
          'The track was updated and is being processed. It will appear in the list shortly.',
      })
    } else {
      toast.push({
        title: 'Caption track updated',
        status: 'success',
        description: 'Caption track updated successfully',
      })
    }

    onUpdate(result.track, oldTrackId)
    setIsSubmitting(false)
  }

  const handleSubmit = async () => {
    if (!name.trim()) {
      toast.push({
        title: 'Audio name required',
        status: 'error',
        description: 'Please enter an audio name for this caption track',
      })
      return
    }

    if (!languageCode.trim()) {
      toast.push({
        title: 'Language code required',
        status: 'error',
        description: 'Please enter a language code (e.g., en, es, fr)',
      })
      return
    }

    setIsSubmitting(true)

    try {
      if (!asset.assetId) {
        throw new Error('Asset ID is required')
      }

      const hasMetadataChanges =
        name.trim() !== (track.name || '') || languageCode.trim() !== (track.language_code || '')

      const originalVttUrl = (() => {
        if (isAutogenerated || !track.id) return ''
        const playbackId = getPlaybackId(asset)
        if (!playbackId) return ''
        let url = `https://stream.mux.com/${playbackId}/text/${track.id}.vtt`
        if (getPlaybackPolicy(asset) === 'signed') {
          const token = generateJwt(client, playbackId, 'v')
          url += `?token=${token}`
        }
        return url
      })()

      const urlChanged = vttUrl.trim() && vttUrl.trim() !== originalVttUrl

      if (!urlChanged && !hasMetadataChanges) {
        toast.push({
          title: 'No changes',
          status: 'info',
          description: 'No changes to save',
        })
        setIsSubmitting(false)
        return
      }

      if (urlChanged) {
        try {
          void new URL(vttUrl.trim())
        } catch {
          toast.push({
            title: 'Invalid URL',
            status: 'error',
            description: 'Please enter a valid URL (e.g., https://example.com/subtitles.vtt)',
          })
          setIsSubmitting(false)
          return
        }

        await handleUpdateTrackWithNewUrl()
      } else {
        const updatedTrack: MuxTextTrack = {
          ...track,
          name: name.trim(),
          language_code: languageCode.trim(),
        }

        toast.push({
          title: 'Caption track updated',
          status: 'success',
          description: 'Caption track information has been updated',
        })

        onUpdate(updatedTrack)
      }

      onClose()
    } catch (error) {
      toast.push({
        title: 'Failed to update caption track',
        status: 'error',
        description: error instanceof Error ? error.message : 'Please try again',
      })
    } finally {
      setIsSubmitting(false)
    }
  }

  return (
    <Dialog
      id={dialogId}
      header="Edit Caption Track"
      onClose={onClose}
      width={1}
      onClickOutside={onClose}
    >
      <Stack padding={4} space={4}>
        <Stack space={2}>
          <Card
            padding={3}
            marginBottom={isAutogenerated ? 0 : 2}
            tone="transparent"
            border
            radius={2}
          >
            <Flex align="center" justify="space-between">
              <Text>{getCurrentFileName()}</Text>
              <Button
                icon={downloading ? Spinner : DownloadIcon}
                text="Download"
                mode="ghost"
                tone="primary"
                fontSize={1}
                padding={2}
                onClick={handleDownloadCurrentFile}
                disabled={downloading || isSubmitting}
              />
            </Flex>
          </Card>
          {!isAutogenerated && (
            <Stack space={2}>
              <Label htmlFor="vtt-url">VTT File URL</Label>
              <TextInput
                id="vtt-url"
                placeholder="https://example.com/subtitles.vtt"
                value={vttUrl}
                onChange={(e) => setVttUrl(e.currentTarget.value)}
                disabled={isSubmitting}
              />
            </Stack>
          )}
        </Stack>

        <Stack space={2}>
          <Label htmlFor="caption-name">Audio name</Label>
          <Autocomplete
            id="caption-name"
            value={selectedLanguage?.value || ''}
            onChange={(newValue) => {
              const selected = LANGUAGE_OPTIONS.find((opt) => opt.value === newValue)
              if (selected) {
                setSelectedLanguage(selected)
                setLanguageCode(selected.value)
                setName(selected.label)
              }
            }}
            options={LANGUAGE_OPTIONS}
            icon={TranslateIcon}
            placeholder="Select language"
            filterOption={(query, option) =>
              option.label.toLowerCase().indexOf(query.toLowerCase()) > -1 ||
              option.value.toLowerCase().indexOf(query.toLowerCase()) > -1
            }
            openButton
            renderValue={(value) => LANGUAGE_OPTIONS.find((l) => l.value === value)?.label || value}
            renderOption={(option) => (
              <Card data-as="button" padding={3} radius={2} tone="inherit">
                <Text size={2} textOverflow="ellipsis">
                  {option.label} ({option.value})
                </Text>
              </Card>
            )}
            disabled={isSubmitting}
          />
        </Stack>

        <Stack space={2}>
          <Label htmlFor="caption-language">Language Code</Label>
          <TextInput
            id="caption-language"
            placeholder="en-US"
            value={languageCode}
            onChange={(e) => {
              setLanguageCode(e.currentTarget.value)
              if (selectedLanguage && selectedLanguage.value !== e.currentTarget.value) {
                setSelectedLanguage(null)
                if (!name || name === selectedLanguage.label) {
                  setName('')
                }
              }
            }}
            disabled={isSubmitting}
          />
        </Stack>

        <Flex gap={2} justify="flex-end" marginTop={2}>
          <Button text="Cancel" mode="ghost" onClick={onClose} disabled={isSubmitting} />
          <Button
            text="Update Caption Track"
            tone="primary"
            icon={isSubmitting ? Spinner : UploadIcon}
            onClick={handleSubmit}
            disabled={isSubmitting}
          />
        </Flex>
      </Stack>
    </Dialog>
  )
}

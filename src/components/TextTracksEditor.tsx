import {AddIcon, DocumentTextIcon, ResetIcon, TranslateIcon, TrashIcon} from '@sanity/icons'
import {Autocomplete, Button, Card, Code, Flex, Radio, Stack, Text, useToast} from '@sanity/ui'
import LanguagesList from 'iso-639-1'
import {Dispatch} from 'react'

import {
  CustomTextTrack,
  SUPPORTED_MUX_LANGUAGES,
  UploadTextTrack,
  isCustomTextTrack,
} from '../util/types'
import {FormField} from 'sanity'
import FileInputArea from './FileInputArea'
import {uuid} from '@sanity/uuid'

/* -------------------------------- Constants ------------------------------- */

const ALL_LANGUAGE_CODES = LanguagesList.getAllCodes().map((code) => ({
  value: code,
  label: LanguagesList.getNativeName(code),
}))

const SUBTITLE_LANGUAGES: Record<
  Extract<UploadTextTrack, {language_code: any}>['type'],
  {value: string; label: string}[]
> = {
  autogenerated: SUPPORTED_MUX_LANGUAGES.map((lang) => ({
    value: lang.code,
    label: lang.label,
  })),
  subtitles: ALL_LANGUAGE_CODES,
  captions: ALL_LANGUAGE_CODES,
}

const TRACK_TYPES = [
  {value: 'autogenerated', label: 'Auto-generated Subtitles'},
  {value: 'subtitles', label: 'Subtitles'},
  {value: 'captions', label: 'Closed Captions'},
] as const

/* --------------------------------- Typings -------------------------------- */

type TrackSubAction =
  | {subAction: 'add'}
  | {subAction: 'update'; value: Partial<UploadTextTrack>}
  | {subAction: 'delete'}

export type TrackAction = {action: 'track'; id: string} & TrackSubAction

/**
 * Handles editing of a single text track, dispatching actions back to the
 * parent UploadConfiguration state object for changing internal state.
 *
 * @param param0
 * @returns
 */
function TrackEditor({
  canAutoGenerate,
  track,
  dispatch,
}: {
  canAutoGenerate?: boolean
  track: Partial<UploadTextTrack> & {_id: string}
  dispatch: Dispatch<TrackAction>
}) {
  const {_id: id, type} = track
  const toast = useToast()
  const dispatchTrackAction = (args: TrackSubAction) => dispatch({action: 'track', id, ...args})

  // function handleFileChange(e: React.ChangeEvent<HTMLInputElement>) {
  //   const file = e.currentTarget.files?.[0]
  //   if (!file) return

  //   if (file.type !== 'text/vtt' && file.type !== 'text/srt') {
  //     e.currentTarget.files = null
  //     toast.push({
  //       status: 'error',
  //       title: 'Invalid file type',
  //     })
  //     return
  //   }

  //   fileToTrackFile(file)
  //     .then((trackFile) => {
  //       modifyTrack({
  //         file: trackFile,
  //       })
  //     })
  //     .catch(() => {
  //       toast.push({
  //         status: 'error',
  //         title: 'Failed processing file',
  //       })
  //     })
  // }

  return (
    <Card border padding={3} radius={2} style={{position: 'relative'}}>
      <Stack space={3}>
        <FormField
          title="Track Type"
          description={
            <>
              Specify whether this track contains{' '}
              <a
                href="https://www.ai-media.tv/knowledge-hub/insights/closed-captions-vs-subtitles"
                target="_blank"
                rel="noopener noreferrer"
              >
                Subtitles or Closed Captions
              </a>
              .
            </>
          }
        >
          <Flex gap={3}>
            {TRACK_TYPES.filter(({value}) => !(value === 'autogenerated' && !canAutoGenerate)).map(
              ({value, label}) => {
                const inputId = `${id}--type-${value}`
                return (
                  <Flex key={value} align="center" gap={2}>
                    <Radio
                      checked={type === value}
                      name="track-type"
                      onChange={(e) =>
                        dispatchTrackAction({
                          subAction: 'update',
                          value: {
                            type: e.currentTarget.value as UploadTextTrack['type'],
                          },
                        })
                      }
                      value={value}
                      id={inputId}
                    />
                    <Text as="label" htmlFor={inputId}>
                      {label}
                    </Text>
                  </Flex>
                )
              }
            )}
          </Flex>
        </FormField>

        <Autocomplete
          id={`${id}--language`}
          value={track.language_code}
          onChange={(newValue) =>
            dispatchTrackAction({
              subAction: 'update',
              value: {
                language_code: newValue,
                name: LanguagesList.getNativeName(newValue),
              },
            })
          }
          options={SUBTITLE_LANGUAGES[track.type!]}
          icon={TranslateIcon}
          placeholder="Select language"
          filterOption={(query, option) =>
            option.label.toLowerCase().indexOf(query.toLowerCase()) > -1 ||
            option.value.toLowerCase().indexOf(query.toLowerCase()) > -1
          }
          openButton
          renderValue={(value) =>
            SUBTITLE_LANGUAGES[track.type!].find((l) => l.value === value)?.label || value
          }
          renderOption={(option) => (
            <Card data-as="button" padding={3} radius={2} tone="inherit">
              <Text size={2} textOverflow="ellipsis">
                {option.label} ({option.value})
              </Text>
            </Card>
          )}
        />

        {isCustomTextTrack(track) &&
          (track.file ? (
            <div style={{position: 'relative'}}>
              <Card
                tone="transparent"
                paddingX={3}
                paddingY={4}
                border
                radius={1}
                style={{
                  maxHeight: '250px',
                  overflowY: 'auto',
                }}
              >
                <Code>{track.file?.contents}</Code>
              </Card>
              <Button
                icon={ResetIcon}
                mode="bleed"
                style={{position: 'absolute', top: '1em', right: '1em'}}
                text="Replace"
                tone="critical"
                onClick={() => {
                  dispatchTrackAction({
                    subAction: 'update',
                    value: {file: undefined},
                  })
                }}
              />
            </div>
          ) : (
            <FileInputArea
              accept=".vtt, .srt"
              acceptMIMETypes={['text/vtt', 'text/srt']}
              label={
                <>
                  <Flex justify="center">
                    <Text muted>
                      <DocumentTextIcon />
                    </Text>
                  </Flex>
                  <Flex justify="center">
                    <Text size={1} muted>
                      Drag or select subtitles file (.vtt, .srt)
                    </Text>
                  </Flex>
                </>
              }
              onSelect={() => {}}
            />
          ))}

        <Flex>
          <Button
            icon={TrashIcon}
            tone="critical"
            mode="ghost"
            onClick={() => dispatchTrackAction({subAction: 'delete'})}
            text="Delete"
          />
        </Flex>
      </Stack>
    </Card>
  )
}

export default function TextTracksEditor({
  canAutoGenerate,
  tracks,
  dispatch,
}: {
  canAutoGenerate?: boolean
  tracks: (Partial<UploadTextTrack> & {_id: string})[]
  dispatch: Dispatch<TrackAction>
}) {
  return (
    <FormField
      title="Captions & Subtitles"
      description="Provide text tracks for video accessibility."
    >
      <Stack space={2}>
        {tracks.map((track) => (
          <TrackEditor
            key={track._id}
            canAutoGenerate={canAutoGenerate}
            track={track}
            dispatch={dispatch}
          />
        ))}
        <Button
          icon={AddIcon}
          onClick={() => dispatch({action: 'track', id: uuid(), subAction: 'add'})}
          text="New caption/subtitle"
          mode="ghost"
        />
      </Stack>
    </FormField>
  )
}

function getFileTextContents(file: File) {
  return new Promise<string>((resolve, reject) => {
    const reader = new FileReader()

    reader.onload = () => {
      if (typeof reader.result === 'string') {
        resolve(reader.result)
      } else {
        reject(new Error('Could not read file'))
      }
    }

    reader.onerror = reject

    reader.readAsText(file)
  })
}

async function fileToTrackFile(file: File) {
  return {
    name: file.name,
    size: file.size,
    type: file.type,
    contents: await getFileTextContents(file),
  }
}

import {AddIcon, ResetIcon, TranslateIcon, TrashIcon} from '@sanity/icons'
import {
  Autocomplete,
  Button,
  Card,
  Checkbox,
  Code,
  Flex,
  Radio,
  Stack,
  Text,
  TextInput,
  useToast,
} from '@sanity/ui'
import LanguagesList from 'iso-639-1'
import {useId} from 'react'

import {
  AutogeneratedTextTrack,
  CustomTextTrack,
  SUPPORTED_MUX_LANGUAGES,
  SUPPORTED_MUX_LANGUAGES_VALUES,
  SupportedMuxLanguage,
  UploadTextTrack,
  isCustomTextTrack,
} from '../util/types'
import FormField from './FormField'

const LANGUAGES: Record<UploadTextTrack['type'], {value: string; label: string}[]> = {
  autogenerated: SUPPORTED_MUX_LANGUAGES.map((lang) => ({
    value: lang.code,
    label: lang.label,
  })),
  custom: LanguagesList.getAllCodes().map((code) => ({
    value: code,
    label: LanguagesList.getNativeName(code),
  })),
}

const TRACK_TYPES = [
  {value: 'autogenerated', label: 'Auto-generated'},
  {value: 'custom', label: 'Custom'},
] as const

function TrackEditor({
  track,
  modifyTrack,
  deleteTrack,
}: {
  track: Partial<UploadTextTrack>
  modifyTrack: (track: Partial<UploadTextTrack>) => void
  deleteTrack: () => void
}) {
  const id = useId()
  const toast = useToast()
  const {type = 'autogenerated'} = track

  function handleTypeChange(event: React.ChangeEvent<HTMLInputElement>) {
    const newType = event.currentTarget.value as typeof type

    modifyTrack({type: newType})
    if (
      newType === 'autogenerated' &&
      !SUPPORTED_MUX_LANGUAGES_VALUES.includes(track.language_code as SupportedMuxLanguage)
    ) {
      modifyTrack({language_code: undefined})
    }
  }

  function handleLanguageChange(newValue: string) {
    if (type === 'autogenerated') {
      modifyTrack({
        language_code: newValue,
      } as Partial<AutogeneratedTextTrack>)
    } else {
      modifyTrack({
        language_code: newValue,
        name: LanguagesList.getNativeName(newValue),
        closed_captions: 'closed_captions' in track ? track.closed_captions : false,
      } as Partial<CustomTextTrack>)
    }
  }

  function handleFileChange(e: React.ChangeEvent<HTMLInputElement>) {
    const file = e.currentTarget.files?.[0]
    if (!file) return

    if (file.type !== 'text/vtt' && file.type !== 'text/srt') {
      e.currentTarget.files = null
      toast.push({
        status: 'error',
        title: 'Invalid file type',
      })
      return
    }

    fileToTrackFile(file)
      .then((trackFile) => {
        modifyTrack({
          file: trackFile,
        })
      })
      .catch(() => {
        toast.push({
          status: 'error',
          title: 'Failed processing file',
        })
      })
  }

  return (
    <Card border padding={3} radius={2} as="form" style={{position: 'relative'}}>
      <Stack space={3}>
        <fieldset style={{all: 'unset'}}>
          <Stack space={2}>
            <Text as="legend" size={1} weight="semibold">
              Type
            </Text>
            {TRACK_TYPES.map(({value, label}) => {
              const inputId = `${id}--type-${value}`
              return (
                <Flex key={value} align="center" gap={2}>
                  <Radio
                    checked={type === value}
                    name="track-type"
                    onChange={handleTypeChange}
                    value={value}
                    id={inputId}
                  />
                  <Text as="label" htmlFor={inputId}>
                    {label}
                  </Text>
                </Flex>
              )
            })}
          </Stack>
        </fieldset>

        <Autocomplete
          id={`${id}--language`}
          value={track.language_code}
          onChange={handleLanguageChange}
          options={LANGUAGES[type]}
          icon={TranslateIcon}
          placeholder="Select language"
          filterOption={(query, option) =>
            option.label.toLowerCase().indexOf(query.toLowerCase()) > -1 ||
            option.value.toLowerCase().indexOf(query.toLowerCase()) > -1
          }
          openButton
          renderValue={(value) => LANGUAGES[type].find((l) => l.value === value)?.label || value}
          renderOption={(option) => (
            <Card data-as="button" padding={3} radius={2} tone="inherit">
              <Text size={2} textOverflow="ellipsis">
                {option.label} ({option.value})
              </Text>
            </Card>
          )}
        />

        {isCustomTextTrack(track) && (
          <>
            {track.file ? (
              <div style={{position: 'relative'}}>
                <Card
                  tone="transparent"
                  paddingX={3}
                  paddingY={4}
                  border
                  radius={1}
                  style={{
                    maxHeight: '250px',
                    overflowY: 'auto',
                  }}
                >
                  <Code>{track.file?.contents}</Code>
                </Card>
                <Button
                  icon={ResetIcon}
                  mode="bleed"
                  style={{position: 'absolute', top: '1em', right: '1em'}}
                  text="Replace"
                  tone="critical"
                  onClick={() => {
                    modifyTrack({
                      file: undefined,
                    })
                  }}
                />
              </div>
            ) : (
              <Stack as="label" space={1}>
                <Text>Subtitles file (.vtt or .srt)</Text>
                <TextInput
                  name="file"
                  type={'file' as any}
                  required
                  onChange={handleFileChange}
                  accept=".vtt,.srt"
                />
              </Stack>
            )}

            <Flex align="center" gap={2}>
              <Checkbox
                id={`${id}--closed-captions`}
                style={{display: 'block'}}
                name="closed-captions"
                required
                checked={(track as CustomTextTrack).closed_captions || false}
                onChange={(e) => {
                  modifyTrack({
                    closed_captions: e.currentTarget.checked,
                  })
                }}
              />
              <Text>
                <label htmlFor={`${id}--closed-captions`}>Closed captions</label>
              </Text>
            </Flex>
          </>
        )}

        <Flex>
          <Button
            icon={TrashIcon}
            tone="critical"
            mode="ghost"
            onClick={deleteTrack}
            text="Delete"
          />
        </Flex>
      </Stack>
    </Card>
  )
}

export default function TextTracksEditor({
  tracks,
  setTracks,
}: {
  tracks: Partial<UploadTextTrack>[]
  setTracks: (newTracks: Partial<UploadTextTrack>[]) => void
}) {
  function modifyTrack(index: number) {
    return (newValues: Partial<UploadTextTrack>) => {
      setTracks(
        tracks.map((track, i) => {
          if (i === index) {
            return {
              ...track,
              ...newValues,
            } as Partial<UploadTextTrack>
          }
          return track
        }) || [newValues]
      )
    }
  }

  function deleteTrack(index: number) {
    return () => {
      setTracks((tracks || []).filter((_, i) => i !== index))
    }
  }

  function addNewTrack() {
    setTracks([
      ...(tracks || []),
      {
        type: 'autogenerated',
      },
    ])
  }

  return (
    <FormField title="Captions/subtitles" inputId="add-captions">
      <Stack space={2}>
        {tracks.map((track, index) => (
          <TrackEditor
            key={index}
            track={track}
            modifyTrack={modifyTrack(index)}
            deleteTrack={deleteTrack(index)}
          />
        ))}
        <Button
          icon={AddIcon}
          id="add-captions"
          onClick={addNewTrack}
          text="New caption/subtitle"
          mode="ghost"
        />
      </Stack>
    </FormField>
  )
}

function getFileTextContents(file: File) {
  return new Promise<string>((resolve, reject) => {
    const reader = new FileReader()

    reader.onload = () => {
      if (typeof reader.result === 'string') {
        resolve(reader.result)
      } else {
        reject(new Error('Could not read file'))
      }
    }

    reader.onerror = reject

    reader.readAsText(file)
  })
}

async function fileToTrackFile(file: File) {
  return {
    name: file.name,
    size: file.size,
    type: file.type,
    contents: await getFileTextContents(file),
  }
}

import {AddIcon, DocumentTextIcon, ResetIcon, TranslateIcon, TrashIcon} from '@sanity/icons'
import {Autocomplete, Button, Card, Code, Flex, Radio, Stack, Text} from '@sanity/ui'
import LanguagesList from 'iso-639-1'
import {Dispatch} from 'react'

import {uuid} from '@sanity/uuid'
import {FormField} from 'sanity'
import {SUPPORTED_MUX_LANGUAGES, UploadTextTrack, isCustomTextTrack} from '../util/types'
import FileInputArea from './FileInputArea'

const ALL_LANGUAGE_CODES = LanguagesList.getAllCodes().map((code) => ({
  value: code,
  label: LanguagesList.getNativeName(code),
}))

const SUBTITLE_LANGUAGES: Record<
  Extract<UploadTextTrack, {language_code: any}>['type'],
  {value: string; label: string}[]
> = {
  autogenerated: SUPPORTED_MUX_LANGUAGES.map((lang) => ({
    value: lang.code,
    label: lang.label,
  })),
  subtitles: ALL_LANGUAGE_CODES,
  captions: ALL_LANGUAGE_CODES,
}

/**
 * Subtitles and Captions are uploaded via .srt and .vtt files, which we can't currently support
 * due to the lack of a server to receive Mux's requests to these files' URLs.
 *
 * For now, only auto-generated subtitles are supported.
 */
const TRACK_TYPES = [
  {value: 'autogenerated', label: 'Auto-generated Subtitles'},
  // {value: 'subtitles', label: 'Subtitles'},
  // {value: 'captions', label: 'Closed Captions'},
] as const

type TrackSubAction =
  | {subAction: 'add'}
  | {subAction: 'update'; value: Partial<UploadTextTrack>}
  | {subAction: 'delete'}

export type TrackAction = {action: 'track'; id: string} & TrackSubAction

/**
 * Handles editing of a single text track, dispatching actions back to the
 * parent UploadConfiguration state object for changing internal state.
 */
function TrackEditor({
  canAutoGenerate,
  track,
  dispatch,
}: {
  canAutoGenerate: boolean
  track: Partial<UploadTextTrack> & {_id: string}
  dispatch: Dispatch<TrackAction>
}) {
  const {_id: id, type} = track
  const dispatchTrackAction = (args: TrackSubAction) => dispatch({action: 'track', id, ...args})

  const trackTypes = TRACK_TYPES.filter(
    ({value}) => !(value === 'autogenerated' && !canAutoGenerate)
  )

  if (trackTypes.length === 0) return null

  return (
    <Card border padding={3} radius={2} style={{position: 'relative'}}>
      <Stack space={3}>
        {trackTypes.length > 1 && (
          <FormField title="Auto-generated subtitles">
            <Flex gap={3}>
              {trackTypes.map(({value, label}) => {
                const inputId = `${id}--type-${value}`
                return (
                  <Flex key={value} align="center" gap={2}>
                    <Radio
                      checked={type === value}
                      name="track-type"
                      onChange={(e) =>
                        dispatchTrackAction({
                          subAction: 'update',
                          value: {
                            type: e.currentTarget.value as UploadTextTrack['type'],
                          },
                        })
                      }
                      value={value}
                      id={inputId}
                    />
                    <Text as="label" htmlFor={inputId}>
                      {label}
                    </Text>
                  </Flex>
                )
              })}
            </Flex>
          </FormField>
        )}

        <Autocomplete
          id={`${id}--language`}
          value={track.language_code}
          onChange={(newValue) =>
            dispatchTrackAction({
              subAction: 'update',
              value: {
                language_code: newValue,
                name: LanguagesList.getNativeName(newValue),
              },
            })
          }
          options={SUBTITLE_LANGUAGES[track.type!]}
          icon={TranslateIcon}
          placeholder="Select language"
          filterOption={(query, option) =>
            option.label.toLowerCase().indexOf(query.toLowerCase()) > -1 ||
            option.value.toLowerCase().indexOf(query.toLowerCase()) > -1
          }
          openButton
          renderValue={(value) =>
            SUBTITLE_LANGUAGES[track.type!].find((l) => l.value === value)?.label || value
          }
          renderOption={(option) => (
            <Card data-as="button" padding={3} radius={2} tone="inherit">
              <Text size={2} textOverflow="ellipsis">
                {option.label} ({option.value})
              </Text>
            </Card>
          )}
        />

        <Flex>
          <Button
            icon={TrashIcon}
            tone="critical"
            mode="ghost"
            onClick={() => dispatchTrackAction({subAction: 'delete'})}
            text="Delete"
          />
        </Flex>
      </Stack>
    </Card>
  )
}

export default function TextTracksEditor({
  canAutoGenerate,
  tracks,
  dispatch,
}: {
  canAutoGenerate: boolean
  tracks: (Partial<UploadTextTrack> & {_id: string})[]
  dispatch: Dispatch<TrackAction>
}) {
  const trackTypes = TRACK_TYPES.filter(
    ({value}) => !(value === 'autogenerated' && !canAutoGenerate)
  )

  if (trackTypes.length === 0) return null

  return (
    <FormField
      title="Captions & Subtitles"
      description="Provide text tracks for video accessibility."
    >
      <Stack space={2}>
        {tracks.map((track) => (
          <TrackEditor
            key={track._id}
            canAutoGenerate={canAutoGenerate}
            track={track}
            dispatch={dispatch}
          />
        ))}
        <Button
          icon={AddIcon}
          onClick={() => dispatch({action: 'track', id: uuid(), subAction: 'add'})}
          text="New caption/subtitle"
          mode="ghost"
        />
      </Stack>
    </FormField>
  )
}

function getFileTextContents(file: File) {
  return new Promise<string>((resolve, reject) => {
    const reader = new FileReader()

    reader.onload = () => {
      if (typeof reader.result === 'string') {
        resolve(reader.result)
      } else {
        reject(new Error('Could not read file'))
      }
    }

    reader.onerror = reject

    reader.readAsText(file)
  })
}

async function fileToTrackFile(file: File) {
  return {
    name: file.name,
    size: file.size,
    type: file.type,
    contents: await getFileTextContents(file),
  }
}

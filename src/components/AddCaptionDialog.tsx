import {TranslateIcon, UploadIcon} from '@sanity/icons'
import {
  Autocomplete,
  Button,
  Card,
  Checkbox,
  Dialog,
  Flex,
  Label,
  Spinner,
  Stack,
  Text,
  TextInput,
  useToast,
} from '@sanity/ui'
import LanguagesList from 'iso-639-1'
import {useId, useState} from 'react'
import {styled} from 'styled-components'

import {addTextTrackFromUrl, generateSubtitles, getAsset} from '../actions/assets'
import {useClient} from '../hooks/useClient'
import {pollTrackStatus} from '../util/pollTrackStatus'
import type {MuxTextTrack, VideoAssetDocument} from '../util/types'

const IconWrapper = styled.span`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  vertical-align: middle;
`

const LANGUAGE_OPTIONS = LanguagesList.getAllCodes().map((code) => ({
  value: code,
  label: LanguagesList.getNativeName(code),
}))

export interface Props {
  asset: VideoAssetDocument
  onAdd: (track: MuxTextTrack) => void
  onClose: () => void
}

export default function AddCaptionDialog({asset, onAdd, onClose}: Props) {
  const client = useClient()
  const toast = useToast()
  const dialogId = `AddCaptionDialog${useId()}`

  const [isAutogenerated, setIsAutogenerated] = useState(false)
  const [vttUrl, setVttUrl] = useState('')
  const [languageCode, setLanguageCode] = useState('')
  const [selectedLanguage, setSelectedLanguage] = useState<{value: string; label: string} | null>(
    null
  )
  const [name, setName] = useState('')
  const [isSubmitting, setIsSubmitting] = useState(false)

  const extractErrorMessage = (error: unknown): string => {
    if (error && typeof error === 'object') {
      const err = error as {response?: {body?: {message?: string}}; message?: string}
      if (err.response?.body?.message) {
        return err.response.body.message
      }
      if (err.message) {
        return err.message
      }
    }
    if (typeof error === 'string') {
      return error
    }
    return 'Failed to add caption track'
  }

  const handleAddTrackFromUrl = async () => {
    if (!asset.assetId) {
      throw new Error('Asset ID is required')
    }

    const trimmedName = name.trim()
    const trimmedLanguageCode = languageCode.trim()

    try {
      await addTextTrackFromUrl(client, asset.assetId, vttUrl.trim(), {
        language_code: trimmedLanguageCode,
        name: trimmedName,
        text_type: 'subtitles',
      })
    } catch (error: unknown) {
      toast.push({
        title: 'Failed to add caption track',
        status: 'error',
        description: extractErrorMessage(error),
      })
      throw error
    }

    const result = await pollTrackStatus({
      client,
      assetId: asset.assetId,
      trackName: trimmedName,
      trackLanguageCode: trimmedLanguageCode,
      onTrackErrored: (track) => {
        const errorMessage =
          track.error?.messages?.[0] ||
          track.error?.type ||
          'The track failed to download from the provided URL'
        toast.push({
          title: 'Caption track failed',
          status: 'error',
          description: errorMessage,
        })
        onAdd(track)
        onClose()
      },
    })

    if (!result.found || !result.track) {
      toast.push({
        title: 'Caption track may have been added',
        status: 'warning',
        description:
          'The track was created but its status could not be determined. It may still be processing. Please refresh the page to see if it appears.',
      })
      onClose()
      return
    }

    if (result.status === 'errored') {
      return
    }

    if (result.status === 'preparing') {
      toast.push({
        title: 'Caption track is processing',
        status: 'info',
        description:
          'The track was created and is being processed. It will appear in the list shortly.',
      })
      onAdd(result.track)
      onClose()
      return
    }

    toast.push({
      title: 'Caption track added',
      status: 'success',
      description: 'Caption track added successfully',
    })

    onAdd(result.track)
    onClose()
  }

  const handleGenerateSubtitles = async () => {
    if (!asset.assetId) {
      throw new Error('Asset ID is required')
    }

    const assetData = await getAsset(client, asset.assetId)
    const audioTrack = assetData.data.tracks?.find((track) => track.type === 'audio')

    if (!audioTrack || !audioTrack.id) {
      toast.push({
        title: 'No audio track found',
        status: 'error',
        description:
          'The asset does not have an audio track. Auto-generated subtitles require an audio track.',
      })
      throw new Error('No audio track found')
    }

    await generateSubtitles(client, asset.assetId, audioTrack.id, {
      language_code: languageCode.trim(),
      name: name.trim(),
    })

    const mockTrackId = `generating-${Date.now()}-${Math.random().toString(36).slice(2, 11)}`
    const mockTrack: MuxTextTrack = {
      type: 'text',
      id: mockTrackId,
      text_type: 'subtitles',
      text_source: 'generated_live',
      language_code: languageCode.trim(),
      name: name.trim(),
      status: 'preparing',
    }

    toast.push({
      title: 'Generating subtitles',
      status: 'success',
      description: 'This may take a few minutes',
    })

    onAdd(mockTrack)
    onClose()
  }

  const handleSubmit = async () => {
    if (!isAutogenerated) {
      if (!vttUrl.trim()) {
        toast.push({
          title: 'URL required',
          status: 'error',
          description: 'Please enter a VTT file URL',
        })
        return
      }

      try {
        void new URL(vttUrl.trim())
      } catch {
        toast.push({
          title: 'Invalid URL',
          status: 'error',
          description: 'Please enter a valid URL (e.g., https://example.com/subtitles.vtt)',
        })
        return
      }
    }

    if (!name.trim()) {
      toast.push({
        title: 'Audio name required',
        status: 'error',
        description: 'Please enter an audio name for this caption track',
      })
      return
    }

    if (!languageCode.trim()) {
      toast.push({
        title: 'Language code required',
        status: 'error',
        description: 'Please enter a language code (e.g., en, es, fr)',
      })
      return
    }

    setIsSubmitting(true)

    try {
      if (isAutogenerated) {
        await handleGenerateSubtitles()
      } else {
        await handleAddTrackFromUrl()
      }
    } catch (error) {
      toast.push({
        title: 'Failed to add caption track',
        status: 'error',
        description: error instanceof Error ? error.message : 'Please try again',
      })
    } finally {
      setIsSubmitting(false)
    }
  }

  return (
    <Dialog
      id={dialogId}
      header="Add Caption Track"
      onClose={onClose}
      width={1}
      onClickOutside={onClose}
    >
      <Stack padding={4} space={4}>
        <Stack space={2}>
          <Flex align="center" marginBottom={3}>
            <Checkbox
              id="autogenerated-checkbox"
              style={{display: 'block'}}
              checked={isAutogenerated}
              onChange={(e) => {
                setIsAutogenerated(e.currentTarget.checked)
                if (e.currentTarget.checked) {
                  setVttUrl('')
                }
              }}
              disabled={isSubmitting}
            />
            <Flex flex={1} paddingLeft={2}>
              <Text>
                <label htmlFor="autogenerated-checkbox">Generate captions</label>
              </Text>
            </Flex>
          </Flex>
          {!isAutogenerated && (
            <Stack space={2}>
              <Label htmlFor="vtt-url">VTT File URL</Label>
              <TextInput
                id="vtt-url"
                placeholder="https://example.com/subtitles.vtt"
                value={vttUrl}
                onChange={(e) => setVttUrl(e.currentTarget.value)}
                disabled={isSubmitting}
              />
            </Stack>
          )}
        </Stack>

        <Stack space={2}>
          <Label htmlFor="caption-name">Audio name</Label>
          <Autocomplete
            id="caption-name"
            value={selectedLanguage?.value || ''}
            onChange={(newValue) => {
              const selected = LANGUAGE_OPTIONS.find((opt) => opt.value === newValue)
              if (selected) {
                setSelectedLanguage(selected)
                setLanguageCode(selected.value)
                setName(selected.label)
              }
            }}
            options={LANGUAGE_OPTIONS}
            icon={TranslateIcon}
            placeholder="Select language"
            filterOption={(query, option) =>
              option.label.toLowerCase().indexOf(query.toLowerCase()) > -1 ||
              option.value.toLowerCase().indexOf(query.toLowerCase()) > -1
            }
            openButton
            renderValue={(value) => LANGUAGE_OPTIONS.find((l) => l.value === value)?.label || value}
            renderOption={(option) => (
              <Card data-as="button" padding={3} radius={2} tone="inherit">
                <Text size={2} textOverflow="ellipsis">
                  {option.label} ({option.value})
                </Text>
              </Card>
            )}
            disabled={isSubmitting}
          />
        </Stack>

        <Stack space={2}>
          <Label htmlFor="caption-language">Language Code</Label>
          <TextInput
            id="caption-language"
            placeholder="en-US"
            value={languageCode}
            onChange={(e) => {
              setLanguageCode(e.currentTarget.value)
              if (selectedLanguage && selectedLanguage.value !== e.currentTarget.value) {
                setSelectedLanguage(null)
                if (!name || name === selectedLanguage.label) {
                  setName('')
                }
              }
            }}
            disabled={isSubmitting}
          />
        </Stack>

        <Flex gap={2} justify="flex-end" marginTop={2}>
          <Button text="Cancel" mode="ghost" onClick={onClose} disabled={isSubmitting} />
          <Button
            text="Add Caption Track"
            tone="primary"
            icon={
              isSubmitting ? (
                <IconWrapper>
                  <Spinner />
                </IconWrapper>
              ) : (
                <IconWrapper>
                  <UploadIcon />
                </IconWrapper>
              )
            }
            onClick={handleSubmit}
            disabled={isSubmitting}
          />
        </Flex>
      </Stack>
    </Dialog>
  )
}
